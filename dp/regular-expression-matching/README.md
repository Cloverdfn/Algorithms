# 正则表达式匹配

## 题目

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

``` 
输入:
s = "aa"
p = "a"
输出: false
```

解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:

``` 
输入:
s = "aa"
p = "a*"
输出: true
```

解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3:

``` 
输入:
s = "ab"
p = ".*"
输出: true
```

解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4:

``` 
输入:
s = "aab"
p = "c*a*b"
输出: true
```

解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

``` 
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 思路

两个字符串进行比较，容易想到的是采用两层循环对比。但是这两个字符串并不是一对一进行比较的， `*` 字符存在匹配 0 个或者多个字符的情况，因此需要额外的变量保存前面已经遍历过的状态。

维护零散的变量并不是简单的事情，我们可以考虑将这些变量使用集合来维护。

在遍历过程中，当前的匹配状态依赖于子串的匹配状态的。因此我们可以考虑使用动态规划来做。

动态规划的三要素：

1. base case
2. 最优子结构
3. 状态转移方程

我们采用二维数组 dp，来存储子串的匹配状态，横向表示 p 字符，纵向表示 s 字符。

![20200130104438.png](https://raw.githubusercontent.com/iostalks/images/master/blog/20200130104438.png)

## 1.base case

base case 是状态转移的初始值，横向初始值是以 s 作为空字符串("")与 p 模式字符进行匹配的结果，纵向初始值是以 s 字符串与空模式串 p 进行匹配的结果。

模式串 p 为空字符串时，当且仅当 s 为空字符时才会匹配。

当 s 为空字符时，就不仅仅只与空字符串 p 匹配了。它还与 `a*` 、 `a*b*` 、 `a*b*c*` 、... 匹配。

因此在遇到 `*` 时，空字符串 s 与 p 的匹配情况需要根据 `*` 向前退两个字符的子串匹配情况决定。

> 根据题意 `*` 能够与重复它前面一个字符 0 次或者多次的字符匹配，因此 `*` 前面的字符必然不能为空字符。

以 `s = ""` 和 `p = "a.b*"` 为例子， 当遇到 `*` 时， `"a.b*"` 回退两位的子串是 `"a."` ， `s = ""` 和 `"a."` 不匹配，所以 `s = ""` 与 `a*b*` 也不匹配。

![20200130111146.png](https://raw.githubusercontent.com/iostalks/images/master/blog/20200130111146.png)

用伪代码表示：

``` js
if (p[j] == '*') {
  dp[i][j] = dp[i][j - 2];
}
```

## 2. 最优子结构

s 的子串 s[0:i] 和 p 的子串 p[0:j] 的匹配关系，可以根据 p 在下标 j 处的字符内容分为三种子结构：

1. p[j] == a-z
2. p[j] == '.'
3. p[j] == '*'

如果 p[j] 字符为 a-z ，并且 p[j] != s[i] 那么 dp[i][j] 必然是 false。如果 p[j] == s[i] 或者 p[j] = '.' 字符，s[0:i] 和 p[0:j] 的匹配关系由 dp[i][j] 由 dp[i-1][j-1] 决定。

如果 p[j] 为 `*` ，要考虑当前 s[i] 字符与 `*` 前一个字符 p[j-1] 发生匹配的次数。分为 0 次、1 次和多次情况来讨论。

上述情况都可以由 s[0:i] 和 p[0:j] 子串的三种子结构记录在 dp[i][j] 数组内的状态推导而来。

## 3. 状态转移方程

1. p[j] == s[i]，p[i] 和 s[j] 字符相同，则 s[0:i] 和 p[0:j] 子串的匹配情况由 s[0:i-1] 和 p[0:i-1] 的情况决定；
2. p[j] == '.'， `.` 点符号能够匹配任意的字符，因此 p[0:i] 和 p[0:j] 子串匹配情况由 s[0:i-1] 和 p[0:i-1] 的情况决定；
3. p[j] == '*'， `*` 的处理需分为匹配次数来讨论，我们接下来会讨论；
4. 其它情况均不匹配。

### 星号匹配 0 次

如果星号匹配 0 次，则需要忽略星号以及它前面的一个字符，dp[i][j] 的前一个状态由 s[i] 与 p[j-2] 字符串的匹配情况 dp[i][j-2] 推导。

![20200130160917.png](https://raw.githubusercontent.com/iostalks/images/master/blog/20200130160917.png)

### 星号匹配 1 次

模式串 `a.b*` 与 `aab` 中的 `b` 发生一次匹配。它们的匹配关系由 `a.b` 和 `aab` 的匹配关系 dp[i][j-1] 推导而来。

![20200130162435.png](https://raw.githubusercontent.com/iostalks/images/master/blog/20200130162435.png)

### 星号匹配多次

模式串 `a.b*` 与 `aabb` 中的 `b` 发生多次匹配。它们的匹配关系由 `a.b*` 和 `aab` 的匹配关系 dp[i-1][j] 推导而来。

![20200130164551.png](https://raw.githubusercontent.com/iostalks/images/master/blog/20200130164551.png)

为什么？

这个多次匹配的推导关系有点难以理解，它为什么不是由 dp[i-1][j-1] 推导而来呢？如果由 dp[i-1][j-1] 推导而来，前一个字符可能和当前字符不相同，就不属于重复匹配了。

多次匹配的前提是已经发生了一次匹配，即在 `a.b*` 和 `aab` 的基础上的匹配情况，也就是 dp[i-1][j] 的值。

> 注：图中 dp 数组的维度会比 s 和 p 字符的长度大 1，新增的维度用于存储推导初始值。文中为了方便当前待匹配情况用 dp[i][j] 表示，代码中实际使用的是 dp[i+1][j+1]。

## 链接

[LeetCode](https://leetcode.com/problems/regular-expression-matching/)

[力扣](https://leetcode-cn.com/problems/regular-expression-matching/)