# First Missing Positive（缺失的第一个正数）

## LeetCode 41

- [英文版](https://leetcode.com/problems/first-missing-positive/)

- [中文版](https://leetcode-cn.com/problems/first-missing-positive/)

## 题目

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

```js
输入: [3,4,-1,1]
输出: 2
```

示例 3:

```js
输入: [7,8,9,11,12]
输出: 1
```

说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

## 思路

<details>
<summary>点击展开</summary>
这道题如果对空间复杂度没有限制，遍历一次数组，将元素作为 key 存入字典；再遍历一次字典，查找从 [1, n) 中缺失的最小 key 即可。

然而，题目说只能使用常数空间，说明只能在原地倒腾数组，数组的特性是下标有序，而题目中查找缺失的最小正整数，肯定要按照 [1, n) 的顺序排除查找，它们之间恰好存在差为 1 的关系。

因此，我们可以遍历一次数组，如果当前元素的值没有超过数组大小，就交换到 [元素值 - 1] 的下标，交换完成后，再次遍历新数组，[下标 + 1] 应该等于当前的元素值，否者就是缺失的最小正整数。

交换后的数组：a[0] = 1, a[1] = 2, a[2] = 3…

大致思路已经有了，看上去也并不难，但这是一道 Hard 的题目，还是有坑的。以 [3, 4, -1, 1] 为例，交换到下标 1 后，变为 [-1, 1, 3, 4]，此次交换虽然元素 3 交换到了目标位置，然而 1 并没有，元素 1 应该在下标 0 处的，否者第二次遍历检测不到元素 1。

因此在交换成功后，不能立即交换下一个元素，而是要再次交换当前元素，直到当前元素不满足交换条件为止。
</details>

## 代码实现

| C++ | Java | Python | JavaScript | Go | PHP |
| :--: | :--: | :--: | :--: | :--: | :--: |
| [😀](FirstMissingPositive.cpp) | 🤔 | [😀](FirstMissingPositive.py) | [😀](./index) | 🤔 | 🤔 |
